## 题目描述

有 $2n$ 个垃圾桶分为两组，每组有 $n$ 个垃圾桶共装着 $m$ 个 Milmon，保证每组内的垃圾桶中 Milmon 的数量随机生成（具体方案见题面结尾）。现在垃圾桶被打乱了，你需要把他们重新分为两组，使得每组都有 $m$ 个 Milmon。

## 输入格式

第一行包含两个整数 $n,m$。

第二行包含 $2n$ 个整数用空格隔开。

## 输出格式

输出第一行包含一个整数 $k$。

第二行包含 $k$ 个整数用空格隔开，表示你分出的第一组的元素在原序列中的下标。

本题采用 Special Judge，这意味着如果存在多个解你只需要输出任意一组，输出的顺序也是任意的。

```input1
3 10000
2638 182 2500 4862 2015 7803
```

```output1
3
1 3 4
```

```input2
5 10000000
273356 1714303 4471362 3216141 324838 3436355 2066188 4184886 222777 89794
```

```output2
5
6 7 8 9 10
```

## 子任务

对于所有数据，保证 $1 \leq n \leq 50$，存在正整数 $1 \leq k \leq 12$ 使得 $m = 10^k$，给定的序列随机生成。

本题共 $7$ 个子任务，每个子任务包含 $5$ 个测试点，你必须通过一个子任务的所有测试点以及依赖的子任务才可以拿到对应的分数。

子任务 1（$1$ 分）：保证 $n \leq 9$。

子任务 2（$9$ 分）：保证 $n \leq 18$。

子任务 3（$10$ 分）：保证 $n \leq 25$。

子任务 4（$11$ 分）：保证 $n \leq 35$。

子任务 5（$1$ 分）：保证 $m \leq 10^6$。

子任务 6（$9$ 分）：保证 $m \leq 10^7$。

子任务 7（$12$ 分）：保证 $m \leq 10^8$。

子任务 8（$12$ 分）：保证 $m \leq 10^9$。

子任务 9（$11$ 分）：保证 $m \leq 10^{10}$。

子任务 10（$12$ 分）：保证 $m \leq 10^{11}$。

子任务 11（$12$ 分）：无特殊限制。

## 提示

输入数据使用如下代码生成：

```cpp
#include<bits/stdc++.h>
using namespace std;

mt19937_64 mt_rand(random_device{}());
long long rnd(long long l,long long r){
    return mt_rand()%(r-l+1)+l;
}

int n=50; // 你可以修改此处的值
const long long s=1e10; // 你可以修改此处的值
long long a[101];

int main(){
    printf("%d %lld\n",n,s);
    for(int i=1;i<=n*2;i++)
        a[i]=rnd(1,s);
    a[n]=a[n*2]=s;
    sort(a+1,a+1+n);
    sort(a+1+n,a+1+n*2);
    for(int i=n;i>=1;i--)a[i]-=a[i-1];
    for(int i=n*2;i>=n+2;i--)a[i]-=a[i-1];
    for(int i=1;i<=n*2;i++)
        swap(a[rnd(1,n*2)],a[rnd(1,n*2)]);
    for(int i=1;i<=n*2;i++)
        printf("%lld%c",a[i]," \n"[i==n*2]);
    return 0;
}
```

你也可以使用类似上述代码中获取随机数的方式生成随机数。
