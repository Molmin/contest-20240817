### 子任务 1

枚举所有情况即可，时间复杂度 $O(26^n n^3)$。

### 子任务 2

相当于计数，枚举三个位置即可，时间复杂度 $O(n^3)$。

### 子任务 3

因为如果一个 `?` 不是 `w`、`m`、`y` 三者时等价，所以每个位置只有 $4$ 种情况，枚举即可。时间复杂度 $O(4^n n^3)$。

### 子任务 4

如果后面的子任务的做法实现不够优秀，仍然可以通过该子任务。

### 子任务 5

考虑动态规划，设 $f(i,W,M,Y)$ 表示前 $i$ 个字符中，有 $W$ 个字符 `w`，有 $M$ 个子序列 `w`、`m`，有 $Y$ 个子序列 `w`、`m`、`y` 是否可行。构造只需要倒推即可。注意到只有 $W,M,Y \leq m$ 时状态有效，时间复杂度 $\Theta(n m^3)$。

### 子任务 6 解法 1

可以把子序列的贡献算在字符 `m` 上，贡献为之前的 `w` 的数量乘之后的 `y` 的数量。

仍然考虑动态规划，设 $f(i, j, W, Y)$ 表示前 $i$ 个字符中的 `m` 贡献的子序列数为 $j$，$W$ 表示前 $i$ 个字符有多少个 `w`，$Y$ 表示后 $n-i$ 个字符有多少个 `y` 是否可行。转移时枚举当前位置所填的字符，构造只需要倒推即可。时间复杂度 $\Theta(n^3 m)$。

### 子任务 6 解法 2

注意到子任务 5 的解法中状态表示的只是是否可行，可以使用 `std::bitset` 优化，时间复杂度 $\Theta\left(\dfrac{n m^3}{w}\right)$。

### 正解

注意到子任务 6 的解法 1 中状态表示的只是是否可行，可以使用 `std::bitset` 优化，时间复杂度 $\Theta\left(\dfrac{n^3 m}{w}\right)$。
