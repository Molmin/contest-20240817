### 算法 1

暴力枚举所有子集。时间复杂度 $O(2^{2n} n)$，预期可以通过 $n \leq 18$ 的情况。

### 算法 2

考虑使用 Meet in the Middle，把序列分为两半分别枚举所有子集。时间复杂度 $O(2^n n)$，预期可以通过 $n \leq 36$ 的情况。

### 算法 3

背包求解，构造只需要从后往前推即可。时间复杂度 $O(nm)$。预期可以通过 $m \leq 10^6$ 的情况。

### 算法 4

考虑优化算法 3，注意到求解背包时每个状态的值是布尔类型的，可以使用 `std::bitset` 优化，时间复杂度 $O\left( \dfrac{nm}{w} \right)$，预期可以通过 $m \leq 10^7$ 的情况。

### 算法 5

注意到深度优先搜索的时间复杂度是 $O(2^{2n})$ 的，考虑搜索的剪枝优化，预处理原数列的后缀和，从前向后做深度优先搜索，如果搜索过程中发现后缀和小于当前所分的两组数的差的绝对值就退出。预期可以通过 $n \leq 9$ 或者 $m \leq 10^9$ 的情况。

### 算法 6

考虑优化算法 2，注意到 Meet in the Middle 只能处理 $36$ 个数的问题，可以把数列任意划分为 $36$ 部分做 Meet in the Middle，这样有 $2^{36}$ 种方案，远大于 $10^9$，预期可以通过 $n \leq 18$ 或者 $m \leq 10^9$ 的情况。

### 算法 7

任取一个或者两个素数，以它为模数做背包，构造方案时从后往前倒推。但是这样会遇到两种转移都可行的方案，任意选一种可能导致总和不为 $m$。由于数据随机，所以每次随机选择一个转移，反复随机直到找到方案即可。预期可以通过 $n \leq 9$ 或者 $m \leq 10^{10}$ 的情况。

### 算法 8

把序列分为两半，不断从两部分分别随机子集，用 `std::unordered_map` 存储已经找到过的总和和对应的元素编号，找到和为 $m$ 的就输出。预期可以通过 $n \leq 18$ 或者 $m \leq 10^{11}$ 的情况。

### 算法 9

把序列分为两半，先在第一部分中随机 $10^5$ 个子集，仍然用 `std::unordered_map` 存储，然后再不断随机第二部分的子集直到找到和为 $m$ 的。预期可以通过 $n \leq 9$ 或者 $m \leq 10^{11}$ 的情况。

### 算法 10

不知道为什么，把算法 7 中的素数改为模 $10^6$ 会更优，预期可以通过 $n \leq 18$ 或者 $m \leq 10^{11}$ 的情况。

### 算法 11

考虑优化算法 10，类似地，背包时可以使用 `std::bitset` 优化，从而模数可以改为 $10^7$，提高正确率。可以通过此题。

### 注

本题似乎和提高班、提高转省选班 7 月 11 日 NOIP 模拟赛 B 题《划分》有点关系？但是这题是在该模拟赛之前选定的。

上述预测指的是稳定能够通过的情况。实际评测时评测系统（Hydro）会在一个测试点 TLE 之后自动重测该测试点若干次，所以部分随机化算法在实际评测时效果比上述预测更加优秀。
